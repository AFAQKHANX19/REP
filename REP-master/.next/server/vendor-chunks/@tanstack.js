"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (sync) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQzhIO0FBQzdIO0FBQ3ZDLG9FQUFvRSxrREFBcUIsR0FBRyw0Q0FBZTtBQUMzRztBQUNBLG1CQUFtQiw2Q0FBZ0IsVUFBVSxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFTO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFjO0FBQ25DLGNBQWMsK0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsZ0JBQWdCLGlFQUFhO0FBQzdCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFpQjtBQUN6QywwQkFBMEIsdUVBQW1CO0FBQzdDLGdCQUFnQixnRUFBWTtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9kaXN0L2VzbS9pbmRleC5qcz8wOTE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgVmlydHVhbGl6ZXIsIGVsZW1lbnRTY3JvbGwsIG9ic2VydmVFbGVtZW50T2Zmc2V0LCBvYnNlcnZlRWxlbWVudFJlY3QsIHdpbmRvd1Njcm9sbCwgb2JzZXJ2ZVdpbmRvd09mZnNldCwgb2JzZXJ2ZVdpbmRvd1JlY3QgfSBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuZXhwb3J0ICogZnJvbSBcIkB0YW5zdGFjay92aXJ0dWFsLWNvcmVcIjtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICBjb25zdCByZXJlbmRlciA9IFJlYWN0LnVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pWzFdO1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZTogKGluc3RhbmNlMiwgc3luYykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jKHJlcmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBpbnN0YW5jZTIsIHN5bmMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICgpID0+IG5ldyBWaXJ0dWFsaXplcihyZXNvbHZlZE9wdGlvbnMpXG4gICk7XG4gIGluc3RhbmNlLnNldE9wdGlvbnMocmVzb2x2ZWRPcHRpb25zKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogZWxlbWVudFNjcm9sbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsLFxuICAgIG9ic2VydmVFbGVtZW50UmVjdDogb2JzZXJ2ZVdpbmRvd1JlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gICAgc2Nyb2xsVG9Gbjogd2luZG93U2Nyb2xsLFxuICAgIGluaXRpYWxPZmZzZXQ6ICgpID0+IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zY3JvbGxZIDogMCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgdXNlVmlydHVhbGl6ZXIsXG4gIHVzZVdpbmRvd1ZpcnR1YWxpemVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key:  true && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key:  true && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key:  true && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key:  true && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if ( true && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key:  true && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n      this._scrollToOffset(offset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [latestOffset] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(\n              this.getOffsetForIndex(index, align)\n            );\n            const currentScrollOffset = this.getScrollOffset();\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(latestOffset, currentScrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkU7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFNBQVMsc0RBQXNEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBOEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUF3RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbURBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbURBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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Qyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBZ0JFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcz80MjFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYm91bmNlLCBtZW1vLCBub3RVbmRlZmluZWQsIGFwcHJveEVxdWFsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNvbnN0IGdldFJlY3QgPSAoZWxlbWVudCkgPT4ge1xuICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGVsZW1lbnQ7XG4gIHJldHVybiB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfTtcbn07XG5jb25zdCBkZWZhdWx0S2V5RXh0cmFjdG9yID0gKGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IChyYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBhcnIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSk7XG4gIH07XG4gIGhhbmRsZXIoZ2V0UmVjdChlbGVtZW50KSk7XG4gIGlmICghdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IHRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgaGFuZGxlcih7IHdpZHRoOiBib3guaW5saW5lU2l6ZSwgaGVpZ2h0OiBib3guYmxvY2tTaXplIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlcihnZXRSZWN0KGVsZW1lbnQpKTtcbiAgICB9O1xuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKSA6IHJ1bigpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd1JlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYih7IHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgsIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCB9KTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBzdXBwb3J0c1Njcm9sbGVuZCA9IHR5cGVvZiB3aW5kb3cgPT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBcIm9uc2Nyb2xsZW5kXCIgaW4gd2luZG93O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kID8gKCkgPT4gdm9pZCAwIDogZGVib3VuY2UoXG4gICAgdGFyZ2V0V2luZG93LFxuICAgICgpID0+IHtcbiAgICAgIGNiKG9mZnNldCwgZmFsc2UpO1xuICAgIH0sXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXlcbiAgKTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgaXNSdGwgfSA9IGluc3RhbmNlLm9wdGlvbnM7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbCA/IGVsZW1lbnRbXCJzY3JvbGxMZWZ0XCJdICogKGlzUnRsICYmIC0xIHx8IDEpIDogZWxlbWVudFtcInNjcm9sbFRvcFwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd09mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmYWxsYmFjayA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFhcIiA6IFwic2Nyb2xsWVwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCJdO1xufTtcbmNvbnN0IHdpbmRvd1Njcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jb25zdCBlbGVtZW50U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNsYXNzIFZpcnR1YWxpemVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldFdpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IFtdO1xuICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbFJlY3QgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgdGhpcy5lbGVtZW50c0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgX3JvID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9ybykge1xuICAgICAgICAgIHJldHVybiBfcm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFdpbmRvdyB8fCAhdGhpcy50YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JvID0gbmV3IHRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKSA6IHJ1bigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIF9ybyA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIGRlbGV0ZSBvcHRzMltrZXldO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbE9mZnNldDogMCxcbiAgICAgICAgb3ZlcnNjYW46IDEsXG4gICAgICAgIHBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgcGFkZGluZ0VuZDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nRW5kOiAwLFxuICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgZ2V0SXRlbUtleTogZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgICAgICAgcmFuZ2VFeHRyYWN0b3I6IGRlZmF1bHRSYW5nZUV4dHJhY3RvcixcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgbWVhc3VyZUVsZW1lbnQsXG4gICAgICAgIGluaXRpYWxSZWN0OiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgc2Nyb2xsTWFyZ2luOiAwLFxuICAgICAgICBnYXA6IDAsXG4gICAgICAgIGluZGV4QXR0cmlidXRlOiBcImRhdGEtaW5kZXhcIixcbiAgICAgICAgaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlOiBbXSxcbiAgICAgICAgbGFuZXM6IDEsXG4gICAgICAgIGlzU2Nyb2xsaW5nUmVzZXREZWxheTogMTUwLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpc1J0bDogZmFsc2UsXG4gICAgICAgIHVzZVNjcm9sbGVuZEV2ZW50OiBmYWxzZSxcbiAgICAgICAgdXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgICAgICAuLi5vcHRzMlxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm90aWZ5ID0gKHN5bmMpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcywgc3luYyk7XG4gICAgfTtcbiAgICB0aGlzLm1heWJlTm90aWZ5ID0gbWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2UuZW5kSW5kZXggOiBudWxsXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgIHRoaXMubm90aWZ5KGlzU2Nyb2xsaW5nKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwibWF5YmVOb3RpZnlcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgaW5pdGlhbERlcHM6IFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVuc3Vicy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLl9kaWRNb3VudCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuX3dpbGxVcGRhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZWQgPyB0aGlzLm9wdGlvbnMuZ2V0U2Nyb2xsRWxlbWVudCgpIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgIT09IHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudCAmJiBcIm93bmVyRG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IHRoaXMuc2Nyb2xsRWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGFyZ2V0V2luZG93ID0gKChfYSA9IHRoaXMuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpbmRvdykgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGNhY2hlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpLCB7XG4gICAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QodGhpcywgKHJlY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRPZmZzZXQodGhpcywgKG9mZnNldCwgaXNTY3JvbGxpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBpc1Njcm9sbGluZyA/IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgPCBvZmZzZXQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBpc1Njcm9sbGluZztcbiAgICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHRoaXMuc2Nyb2xsUmVjdCA/PyB0aGlzLm9wdGlvbnMuaW5pdGlhbFJlY3Q7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxSZWN0W3RoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcm9sbE9mZnNldCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5zY3JvbGxPZmZzZXQgPz8gKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQoKSA6IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbE9mZnNldDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudCA9IChtZWFzdXJlbWVudHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IG0gPSBpbmRleCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5oYXMobWVhc3VyZW1lbnQubGFuZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50cy5nZXQoXG4gICAgICAgICAgbWVhc3VyZW1lbnQubGFuZVxuICAgICAgICApO1xuICAgICAgICBpZiAocHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID09IG51bGwgfHwgbWVhc3VyZW1lbnQuZW5kID4gcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuZW5kIDwgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2V0KG1lYXN1cmVtZW50LmxhbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzID8gQXJyYXkuZnJvbShmdXJ0aGVzdE1lYXN1cmVtZW50cy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5lbmQgPT09IGIuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgICAgfSlbMF0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50T3B0aW9ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbixcbiAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXksXG4gICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkXG4gICAgICBdLFxuICAgICAgKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHBhZGRpbmdTdGFydCxcbiAgICAgICAgICBzY3JvbGxNYXJnaW4sXG4gICAgICAgICAgZ2V0SXRlbUtleSxcbiAgICAgICAgICBlbmFibGVkXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAgICh7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCB9LCBpdGVtU2l6ZUNhY2hlKSA9PiB7XG4gICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IHRoaXMub3B0aW9ucy5pbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi50aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcykgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKTtcbiAgICAgICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50ID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gbWVhc3VyZW1lbnRzW2kgLSAxXSA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLmdhcCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSBcIm51bWJlclwiID8gbWVhc3VyZWRTaXplIDogdGhpcy5vcHRpb25zLmVzdGltYXRlU2l6ZShpKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemU7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmxhbmUgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzO1xuICAgICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IG1lYXN1cmVtZW50cztcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0TWVhc3VyZW1lbnRzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLmdldE1lYXN1cmVtZW50cygpLFxuICAgICAgICB0aGlzLmdldFNpemUoKSxcbiAgICAgICAgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmxhbmVzXG4gICAgICBdLFxuICAgICAgKG1lYXN1cmVtZW50cywgb3V0ZXJTaXplLCBzY3JvbGxPZmZzZXQsIGxhbmVzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlID0gbWVhc3VyZW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0ZXJTaXplID4gMCA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICBtZWFzdXJlbWVudHMsXG4gICAgICAgICAgb3V0ZXJTaXplLFxuICAgICAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICB9KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImNhbGN1bGF0ZVJhbmdlXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEluZGV4ZXMgPSBtZW1vKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICAgICAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF5YmVOb3RpZnkudXBkYXRlRGVwcyhbdGhpcy5pc1Njcm9sbGluZywgc3RhcnRJbmRleCwgZW5kSW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIGVuZEluZGV4XG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKHJhbmdlRXh0cmFjdG9yLCBvdmVyc2NhbiwgY291bnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4ID09PSBudWxsIHx8IGVuZEluZGV4ID09PSBudWxsID8gW10gOiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhbixcbiAgICAgICAgICBjb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0VmlydHVhbEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbmRleEZyb21FbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGU7XG4gICAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKCFpbmRleFN0cikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE1pc3NpbmcgYXR0cmlidXRlIG5hbWUgJyR7YXR0cmlidXRlTmFtZX09e2luZGV4fScgb24gbWVhc3VyZWQgZWxlbWVudC5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApO1xuICAgIH07XG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLmVsZW1lbnRzQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUocHJldk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLnNldChrZXksIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVJdGVtKGluZGV4LCB0aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplSXRlbSA9IChpbmRleCwgc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZUNhY2hlLmdldChpdGVtLmtleSkgPz8gaXRlbS5zaXplO1xuICAgICAgY29uc3QgZGVsdGEgPSBzaXplIC0gaXRlbVNpemU7XG4gICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlICE9PSB2b2lkIDAgPyB0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZShpdGVtLCBkZWx0YSwgdGhpcykgOiBpdGVtLnN0YXJ0IDwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY29ycmVjdGlvblwiLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnRzOiB0aGlzLnNjcm9sbEFkanVzdG1lbnRzICs9IGRlbHRhLFxuICAgICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleCk7XG4gICAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAodGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpO1xuICAgICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIWNhY2hlZC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUoY2FjaGVkKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChub2RlLCB2b2lkIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0VmlydHVhbEluZGV4ZXMoKSwgdGhpcy5nZXRNZWFzdXJlbWVudHMoKV0sXG4gICAgICAoaW5kZXhlcywgbWVhc3VyZW1lbnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzW2tdO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgICAgIHZpcnR1YWxJdGVtcy5wdXNoKG1lYXN1cmVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRWaXJ0dWFsSXRlbXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbUZvck9mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFVuZGVmaW5lZChcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgKGluZGV4KSA9PiBub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2luZGV4XSkuc3RhcnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgICldXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQgPSAodG9PZmZzZXQsIGFsaWduLCBpdGVtU2l6ZSA9IDApID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGFsaWduID0gdG9PZmZzZXQgPj0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZSA/IFwiZW5kXCIgOiBcInN0YXJ0XCI7XG4gICAgICB9XG4gICAgICBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgKz0gKGl0ZW1TaXplIC0gc2l6ZSkgLyAyO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgICB0b09mZnNldCAtPSBzaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gdGhpcy5nZXRUb3RhbFNpemUoKSAtIHNpemU7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4T2Zmc2V0LCB0b09mZnNldCksIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleCA9IChpbmRleCwgYWxpZ24gPSBcImF1dG9cIikgPT4ge1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmdldFNjcm9sbE9mZnNldCgpO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAoaXRlbS5lbmQgPj0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZSAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kKSB7XG4gICAgICAgICAgYWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RhcnQgPD0gc2Nyb2xsT2Zmc2V0ICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbc2Nyb2xsT2Zmc2V0LCBhbGlnbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvT2Zmc2V0ID0gYWxpZ24gPT09IFwiZW5kXCIgPyBpdGVtLmVuZCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kIDogaXRlbS5zdGFydCAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQ7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24sIGl0ZW0uc2l6ZSksXG4gICAgICAgIGFsaWduXG4gICAgICBdO1xuICAgIH07XG4gICAgdGhpcy5pc0R5bmFtaWNNb2RlID0gKCkgPT4gdGhpcy5lbGVtZW50c0NhY2hlLnNpemUgPiAwO1xuICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgIT09IG51bGwgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvT2Zmc2V0ID0gKHRvT2Zmc2V0LCB7IGFsaWduID0gXCJzdGFydFwiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXggPSAoaW5kZXgsIHsgYWxpZ246IGluaXRpYWxBbGlnbiA9IFwiYXV0b1wiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0QW5kQWxpZ24gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBpbml0aWFsQWxpZ24pO1xuICAgICAgaWYgKCFvZmZzZXRBbmRBbGlnbikgcmV0dXJuO1xuICAgICAgY29uc3QgW29mZnNldCwgYWxpZ25dID0gb2Zmc2V0QW5kQWxpZ247XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldChvZmZzZXQsIHsgYWRqdXN0bWVudHM6IHZvaWQgMCwgYmVoYXZpb3IgfSk7XG4gICAgICBpZiAoYmVoYXZpb3IgIT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gdGhpcy50YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBlbGVtZW50SW5ET00gPSB0aGlzLmVsZW1lbnRzQ2FjaGUuaGFzKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXkoaW5kZXgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZWxlbWVudEluRE9NKSB7XG4gICAgICAgICAgICBjb25zdCBbbGF0ZXN0T2Zmc2V0XSA9IG5vdFVuZGVmaW5lZChcbiAgICAgICAgICAgICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgYWxpZ24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICBpZiAoIWFwcHJveEVxdWFsKGxhdGVzdE9mZnNldCwgY3VycmVudFNjcm9sbE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxCeSA9IChkZWx0YSwgeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIGRlbHRhLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGxldCBlbmQ7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbmQgPSB0aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubGFuZXMgPT09IDEpIHtcbiAgICAgICAgZW5kID0gKChfYSA9IG1lYXN1cmVtZW50c1ttZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbmQpID8/IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbmRCeUxhbmUgPSBBcnJheSh0aGlzLm9wdGlvbnMubGFuZXMpLmZpbGwobnVsbCk7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoZW5kSW5kZXggPj0gMCAmJiBlbmRCeUxhbmUuc29tZSgodmFsKSA9PiB2YWwgPT09IG51bGwpKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IG1lYXN1cmVtZW50c1tlbmRJbmRleF07XG4gICAgICAgICAgaWYgKGVuZEJ5TGFuZVtpdGVtLmxhbmVdID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRCeUxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmRJbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KC4uLmVuZEJ5TGFuZS5maWx0ZXIoKHZhbCkgPT4gdmFsICE9PSBudWxsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgIGVuZCAtIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyB0aGlzLm9wdGlvbnMucGFkZGluZ0VuZCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gKG9mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvclxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwgeyBiZWhhdmlvciwgYWRqdXN0bWVudHMgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG59XG5jb25zdCBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IChsb3csIGhpZ2gsIGdldEN1cnJlbnRWYWx1ZSwgdmFsdWUpID0+IHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gKGxvdyArIGhpZ2gpIC8gMiB8IDA7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2Uoe1xuICBtZWFzdXJlbWVudHMsXG4gIG91dGVyU2l6ZSxcbiAgc2Nyb2xsT2Zmc2V0LFxuICBsYW5lc1xufSkge1xuICBjb25zdCBsYXN0SW5kZXggPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gKGluZGV4KSA9PiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA8PSBsYW5lcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydEluZGV4OiAwLFxuICAgICAgZW5kSW5kZXg6IGxhc3RJbmRleFxuICAgIH07XG4gIH1cbiAgbGV0IHN0YXJ0SW5kZXggPSBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaChcbiAgICAwLFxuICAgIGxhc3RJbmRleCxcbiAgICBnZXRPZmZzZXQsXG4gICAgc2Nyb2xsT2Zmc2V0XG4gICk7XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGlmIChsYW5lcyA9PT0gMSkge1xuICAgIHdoaWxlIChlbmRJbmRleCA8IGxhc3RJbmRleCAmJiBtZWFzdXJlbWVudHNbZW5kSW5kZXhdLmVuZCA8IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSkge1xuICAgICAgZW5kSW5kZXgrKztcbiAgICB9XG4gIH0gZWxzZSBpZiAobGFuZXMgPiAxKSB7XG4gICAgY29uc3QgZW5kUGVyTGFuZSA9IEFycmF5KGxhbmVzKS5maWxsKDApO1xuICAgIHdoaWxlIChlbmRJbmRleCA8IGxhc3RJbmRleCAmJiBlbmRQZXJMYW5lLnNvbWUoKHBvcykgPT4gcG9zIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSkge1xuICAgICAgY29uc3QgaXRlbSA9IG1lYXN1cmVtZW50c1tlbmRJbmRleF07XG4gICAgICBlbmRQZXJMYW5lW2l0ZW0ubGFuZV0gPSBpdGVtLmVuZDtcbiAgICAgIGVuZEluZGV4Kys7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0UGVyTGFuZSA9IEFycmF5KGxhbmVzKS5maWxsKHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSk7XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPj0gMCAmJiBzdGFydFBlckxhbmUuc29tZSgocG9zKSA9PiBwb3MgPj0gc2Nyb2xsT2Zmc2V0KSkge1xuICAgICAgY29uc3QgaXRlbSA9IG1lYXN1cmVtZW50c1tzdGFydEluZGV4XTtcbiAgICAgIHN0YXJ0UGVyTGFuZVtpdGVtLmxhbmVdID0gaXRlbS5zdGFydDtcbiAgICAgIHN0YXJ0SW5kZXgtLTtcbiAgICB9XG4gICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KDAsIHN0YXJ0SW5kZXggLSBzdGFydEluZGV4ICUgbGFuZXMpO1xuICAgIGVuZEluZGV4ID0gTWF0aC5taW4obGFzdEluZGV4LCBlbmRJbmRleCArIChsYW5lcyAtIDEgLSBlbmRJbmRleCAlIGxhbmVzKSk7XG4gIH1cbiAgcmV0dXJuIHsgc3RhcnRJbmRleCwgZW5kSW5kZXggfTtcbn1cbmV4cG9ydCB7XG4gIFZpcnR1YWxpemVyLFxuICBhcHByb3hFcXVhbCxcbiAgZGVib3VuY2UsXG4gIGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gIGRlZmF1bHRSYW5nZUV4dHJhY3RvcixcbiAgZWxlbWVudFNjcm9sbCxcbiAgbWVhc3VyZUVsZW1lbnQsXG4gIG1lbW8sXG4gIG5vdFVuZGVmaW5lZCxcbiAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gIG9ic2VydmVFbGVtZW50UmVjdCxcbiAgb2JzZXJ2ZVdpbmRvd09mZnNldCxcbiAgb2JzZXJ2ZVdpbmRvd1JlY3QsXG4gIHdpbmRvd1Njcm9sbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) <= 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QixHQUFHLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXLElBQUksT0FBTztBQUNqRSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcz9jZDdhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBvcHRzLmluaXRpYWxEZXBzID8/IFtdO1xuICBsZXQgcmVzdWx0O1xuICBmdW5jdGlvbiBtZW1vaXplZEZ1bmN0aW9uKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYSA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMpKSkgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9iID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0cykpKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYyA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdHMpKSkge1xuICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgc3RyID0gXCIgXCIgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgIGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsXG4gICAgICAgIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMClcbiAgICAgICAgKX1kZWcgMTAwJSAzMSUpO2AsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5XG4gICAgICApO1xuICAgIH1cbiAgICAoX2QgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChvcHRzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWRGdW5jdGlvbi51cGRhdGVEZXBzID0gKG5ld0RlcHMpID0+IHtcbiAgICBkZXBzID0gbmV3RGVwcztcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkRnVuY3Rpb247XG59XG5mdW5jdGlvbiBub3RVbmRlZmluZWQodmFsdWUsIG1zZykge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB1bmRlZmluZWQke21zZyA/IGA6ICR7bXNnfWAgOiBcIlwifWApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgYXBwcm94RXF1YWwgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpIDw9IDE7XG5jb25zdCBkZWJvdW5jZSA9ICh0YXJnZXRXaW5kb3csIGZuLCBtcykgPT4ge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHRhcmdldFdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB0YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSwgbXMpO1xuICB9O1xufTtcbmV4cG9ydCB7XG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;